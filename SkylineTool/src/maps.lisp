(in-package :skyline-tool)

(defclass level ()
  ((sprites :accessor level-sprites :initarg :sprites)
   (grid :accessor level-grid :initarg :grid)
   (objects :accessor level-objects :initarg :objects)
   (name :reader level-name :initarg :name)))

(defvar *screen-ticker* 0)

(defclass grid/tia ()
  ((tiles :reader grid-tiles :initarg :tiles)
   (colors :reader grid-row-colors :initarg :colors)
   (background-color :reader grid-background-color :initarg :background-color)
   (id :reader grid-id :initform (incf *screen-ticker*))))

(defgeneric list-grid-row-colors (grid))
(defgeneric list-grid-tiles (grid))

(defmethod list-grid-row-colors ((grid grid/tia))
  (coerce (grid-row-colors grid) 'list))

(defun list-grid-row-palette-colors (grid)
  (mapcar (curry #'apply #'rgb->palette)
          (apply #'concatenate 'list (list-grid-row-colors grid))))

(defmethod list-grid-tiles ((grid grid/tia))
  (let (list
        (tiles (grid-tiles grid)))
    (dotimes (y 8)
      (dotimes (x 4)
        (push (aref tiles x y) list)))
    (nreverse list)))

(defun assocdr (key alist)
  (or (second (assoc key alist :test #'equalp))
      (error "Could not find ~a in ~s" key alist)))

(defun pin (n min max)
  (min max (max min n)))

(defun parse-tile-collisions (tileset)
  (let ((collisions (make-array (list 256 2 2) :element-type 'bit)))
    (dolist (tile-data (cddr tileset))
      (when (equal "tile" (car tile-data))
        (unless (consp tile-data) (error "fubar"))
        (let ((tile-id (parse-integer (assocdr "id" (second tile-data)))))
          (dolist (object-group (cddr tile-data))
            (when (equal "objectgroup" (car object-group))
              (dolist (object (cddr object-group))
                (assert (equal "object" (car object)))
                (let* ((x1 (floor (parse-number (assocdr "x" (second object)))
                                  4))
                       (y1 (floor (parse-number (assocdr "y" (second object)))
                                  8))
                       (x2 (+ x1 (floor (parse-number (assocdr "width" (second object)))
                                        4)))
                       (y2 (+ y1 (floor (parse-number (assocdr "height" (second object)))
                                        8))))
                  (loop for x from (pin x1 0 1) upto (pin x2 0 1) do 
                    (loop for y from (pin y1 0 1) upto (pin y2 0 1) do
                      (setf (aref collisions tile-id x y) 1))))))))))
    collisions))

(defun parse-tile-collision-bitmap (tileset grid)
  (let ((tile-collisions (parse-tile-collisions tileset))
        (bitmap (make-array (list (* 2 (length (first grid)))
                                  (* 2 (length grid)))
                            :element-type 'bit)))
    (dotimes (y (length grid))
      (let ((row (elt grid y)))
        (dotimes (x (length row))
          (dotimes (yy 2)
            (dotimes (xx 2)
              (setf (aref bitmap (+ xx (* 2 x)) (+ yy (* 2 y)))
                    (aref tile-collisions (max (1- (elt row x)) 0) xx yy)))))))
    bitmap))

(defun parse-tile-animation-sets (tileset)
  (let ((animations (list)))
    (dolist (tile-data (cddr tileset))
      (when (equal "tile" (car tile-data))
        (let ((tile-id (parse-integer (assocdr "id" (second tile-data)))))
          (dolist (animation (cddr tile-data))
            (when (equal "animation" (car animation))
              (let ((sequence (list)))
                (dolist (frame (cddr animation))
                  (assert (equal "frame" (car frame)))
                  (let ((frame-tile (parse-integer (assocdr "tileid" (second frame))))
                        (duration (/ (parse-integer (assocdr "duration" (second frame)))
                                     1000 1/60)))
                    (push frame-tile sequence)
                    (push duration sequence)))
                (push (list tile-id (reverse sequence)) animations)))))))
    animations))

(defun split-into-bytes (tile-collision-bitmap)
  (let ((width (array-dimension tile-collision-bitmap 0))
        (bytes (list)))
    (dotimes (y (array-dimension tile-collision-bitmap 1))
      (dotimes (byte (floor width 8))
        (let ((value 0))
          (dotimes (bit 8)
            (let ((x (+ bit (* 8 byte))))
              (when (< x width)
                (when (plusp (aref tile-collision-bitmap x y))
                  (setf value (logior value (ash 1 bit)))))))
          (push value bytes))))
    (reverse bytes)))

(defun parse-tile-grid (layer)
  (let* ((grid (mapcar (lambda (row) 
                         (mapcar (lambda (tile) (max (1- tile) 0))
                                 (mapcar #'parse-integer (remove-if #'emptyp (split-sequence #\, row)))))
                       (split-sequence #\newline (lastcar (third layer))))))
    (assert (equal "csv" (assocdr "encoding" (second (third layer)))))
    grid))

(defun compile-map (pathname)
  (let ((xml (xmls:parse-to-list (alexandria:read-file-into-string pathname))))
    (assert (equal "map" (car xml)))
    (assert (equal "orthogonal" (assocdr "orientation" (second xml))))
    (assert (equal "right-down" (assocdr "renderorder" (second xml))))
    (assert (equal "8" (assocdr "tilewidth" (second xml))))
    (assert (equal "16" (assocdr "tileheight" (second xml))))
    (assert (equal "tileset" (car (third xml))))
    (assert (equal "layer" (car (fourth xml))))
    (assert (equal "layer" (car (fifth xml))))
    (assert (equal "layer" (car (sixth xml))))
    (assert (equal "256" (assocdr "tilecount" (second (third xml)))))
    (let ((tile-animation-sets (parse-tile-animation-sets (third xml)))
          ;; (background-color (parse-background-color (or (ignore-errors (assocdr "backgroundcolor" (second xml)))
          ;;                                               "#00ffff" #|default cyan|#)))
          )
      (format t ";;; This is a generated file.~%;;; Source file: ~a~2%" pathname)
      (let* ((tile-grid (parse-tile-grid (fourth xml)))
             (tile-attributes (parse-tile-attributes (fourth xml)))
             (height (length tile-grid))
             (width (length (first tile-grid))))
        (format t "~2%;;; Tile grid — ~d × ~d tiles~%	.byte ~d, ~d" width height width height)
        (format t "~2%;;; Background color~%	.byte ~d" background-color)
        (format t "~{~%~{~%	.byte $~2,'0x~^, $~2,'0x~^, $~2,'0x~^, $~2,'0x~^,  ~
$~2,'0x~^, $~2,'0x~^, $~2,'0x~^, $~2,'0x~^,  ~
$~2,'0x~^, $~2,'0x~^, $~2,'0x~^, $~2,'0x~^,  ~
$~2,'0x~^, $~2,'0x~^, $~2,'0x~^, $~2,'0x~}~}" tile-grid)
        (format t "~2%;;; Tile collision bitmap — ~d × ~d quarter-tile cells" (* 2 width) (* 2 height))
        (let ((tile-collision-bitmap (parse-tile-collision-bitmap (third xml) tile-grid)))
          (format t "~{~%	.byte $~2,'0x~^, $~2,'0x~^, $~2,'0x~^, $~2,'0x~^,  ~
$~2,'0x~^, $~2,'0x~^, $~2,'0x~^, $~2,'0x~^,  ~
$~2,'0x~^, $~2,'0x~^, $~2,'0x~^, $~2,'0x~^,  ~
$~2,'0x~^, $~2,'0x~^, $~2,'0x~^, $~2,'0x~}"
                  (split-into-bytes tile-collision-bitmap)))
        (format t "~2%;;; Tile animation sets — ~d animation set~:p" (length tile-animation-sets))
        (format t "~%	.byte ~d~%" (length tile-animation-sets))
        (format t "~{~{~%	.byte $~2,'0x,  ~{$~2,'0x, ~3d~^, ~}, 0~}~}" tile-animation-sets))
      (fresh-line))))

